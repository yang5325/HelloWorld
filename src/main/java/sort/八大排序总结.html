<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

<h2>排序算法</h2>
    时间复杂度在n-n²、看数据的有序程度 是稳定的排序算法
<h2>选择升序排序</h2>
    遍历数组、找到最小值、 然后交换到数组的最左端
    在剩余未排序数组继续寻找 用数组实现的话不是稳定的排序算法
    固有的n²复杂度
<h2>插入升序排序</h2>

    将待排序数组分为已排序和未排序的两部分、开始时、默认第一个数据就是有序的。
    然后在遍历的过程中、不断比较当前索引对应的值与前一位值的大小、
        如果比前一位小、则交换位置。然后继续比较当前索引-1的值和其前一位的值、
<h2>归并排序</h2>
    是采用分治算法的典型应用、
    即将数组先拆分成只有1个或2个数组的子序列、
    然后再将子序列合并排序到辅助数组、最后copy回来
    是稳定算法、空间复杂度为n
<h2>快排</h2>
    先从数组中挑选一个数据作为基准值、比如第一个
    然后我们需要2个指针、在遍历数组、找到一个比基准值小的和比基准值大的、交换位置
    ologn
<h2>堆排序</h2>
    堆是一棵完全二叉数、所有推荐使用数组来实现 升序排序的时候使用最小堆
    将小顶堆的根节点取出、剩下的堆继续调整为小顶堆、直到堆中只有一个数据为止、
<h2>希尔排序</h2>
    希尔排序的插入排序的改良版、我认为他最大的优点是克服了插入排序每次只能向前移动一位的缺点。
    他需要一个增量、默认取数组长度的一半、然后依次减半、但要求最小为1、
    然后顺序遍历、比较当前索引的值和当前索引加一个增量的值、条件满足则交换、
<h2>基数排序</h2>

<h2>ThreadLocal</h2>



</body>
</html>